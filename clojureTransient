                                              临时数据结构
                                               作者：Rich Hickey
                                               翻译：Gerry Xiao

1、原理

如果一棵树掉进了树林，会发出声音吗？
如果一个纯函数为了计算一个不变的返回值而改变某些局部数据，合适吗？

这是个有趣的问题。Clojure数据结构每当调用诸如assoc之类函数时，在返回结果作为后续使用的不变数据
之前，构建一个或多个数组并改变它们，这么做的原因在于性能--只使用纯函数和不变数据没有这么快。
然而，不变和持续是健壮程序的关键。clojure内部改变的是构成数据结构内部节点的小的新分配的数组，没有
人会看见它们。

当你想通过多步初始化或转换大的持续数据结构，除了构造/转换代码外，没有被其他代码可见的步骤时，你遇到
同样的场景。这里的挑战在于转换的源将是持续不变的数据结构，函数的结果将被共享。拷贝到一个传统的可变
数据结构并返回涉及O（n)拷贝，内部的代码是过程式的，会搅乱其他Clojure代码。而且，没有保证会偶然
共享或混淆可变的数据结构，特别是你想调用辅助函数完成工作时。简言之，为了加速部分代码而离开Clojure
模式是遗憾的事情。临时数据结构是集成于Clojure模式对这种优化问题的解决方案，而不会影响你所期盼的
clojure线程安全保证。

2、它们如何工作

临时数据结构总是从一个存在的持续不变的clojure数据结构创建。当前只支持矢量vector,注意不是所有的
clojure数据结构支持这个特点，但大多将会。列表不会，因为对其无利可图。

调用transient,你获得数据结构的一份临时拷贝。这是原来数据结构的新的临时数据结构，拥有一样的性能
特征。事实上，它基本上就是原来的数据结构，突出了临时数据结构的第一个特点，创建操作是O(1),它和源
共享结构，就如持续拷贝共享结构一样。

它的第二个特征就是创建临时数据结构并不改变原有的数据结构，原数据结构也不能被改变，它是不变持续的。

临时数据结构支持源的只读接口，如，你可以调用nth,get,cout等，如持续矢量结构一样。

临时数据结构并不支持源数据结构的持续操作接口。assoc,conj等会引发意外。因为，临时数据结构不持续。
所以，你不可能偶然的泄露一个临时数据结构到一个要求持续的上下文中。

临时数据结构支持一套并行的“改变”操作，有着相似的名称，不过后面加上感叹号！-assoc! conj!等，它们
和同等的持续版本功能是相同的，除了返回值本身是临时的。特别注意，临时数据结构不是摆在那里让你随意
改变的，你必须在下一次调用中捕获和使用返回值。通过这种方式，他们和他们所代替的函数式持续代码构造是
一致的。如下例所示，可以毋须结构化改变，就可以增强代码的性能。

完成结果构建后，你可以对临时数据结构调用persistent!来创建一个持续的数据结构。这个操作是O(1).
调用persistent!的后果就是，这个临时数据结构再也不能使用了，所有的操作会引发意外。这也包括你对它
创立的别名。

3、例子
这是个典型例子，一些代码构建矢量返回，所有“改变”对函数而言是局部的。注意使用临时数据结构版本和不
使用临时结构的版本结构是一样的,只是：
＊对源矢量调用transient函数
＊使用conj!而不是conj
＊对返回值persistent!

defn vrange [n]
  (loop [i 0 v []]
    (if (< i n)
      (recur (inc i) (conj v i))
      v)))
 
(defn vrange2 [n]
  (loop [i 0 v (transient [])]
    (if (< i n)
      (recur (inc i) (conj! v i))
      (persistent! v))))
 
(time (def v (vrange 1000000)))
"Elapsed time: 297.444 msecs"
 
(time (def v2 (vrange2 1000000)))
"Elapsed time: 34.428 msecs"

噢，transients 快多了


4、并发使用

使用临时数据结构就是这样，但它们还有另外一个重要属性：使用临时数据结构强调线程孤立。因为对临时
数据结构的操作和前面的共享（可变）的数据结构，如果多个线程同时处理它们是危险的。为阻止这种行为
发生，它们将检测操作（读或写）是否来自于创建它们的线程，否则引发意外。

这听起来不是个并发故事。但是单线程孤立实际上是个很有用的并发语义。这么做全部是为了安全，因为它们
的使用是不同于函数式代码的孤立实现细节。如此强制使不安全的可变数据结构变得安全。

＊组合操作是可行的，不需要锁。
  对比java.util.Vector,尽管每个操作是同步的，但你不买账。
＊多集合操作是可行的，不需要锁
  对比其他java.util集合，到处是锁
＊混淆或泄露将被捕获。

5、总结

临时数据结构对clojure函数式数据结构提供一种高性能的优化操作，并且提供重要的安全保障。

＊单流程使用
＊强制线程孤立
＊O（1）创建时间
＊和源数据共享结构
＊O（1）返回时间
＊和函数式版本一样的代码结构
＊捕获返回值，用于下次调用
＊不能就地改变
＊不持续，所以你不能依附中间值或别名
＊持续化后不能使用
＊快


